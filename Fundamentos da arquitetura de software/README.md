
# Fundamentos de Arquitetura de Software:
A disciplina de Fundamentos de Arquitetura de Software abrange diversos aspectos essenciais para o desenvolvimento eficiente e estruturado de sistemas.

  
### Tipos de Arquiteturas:
-   Arquitetura de Software: Refere-se à estrutura organizacional do sistema, delineando componentes, seus relacionamentos e princípios gerais.
-   Arquitetura de Soluções: Situa-se entre os domínios de negócios e software, traduzindo requisitos em soluções de software tangíveis.

### Características da Arquitetura de Soluções:
  -   Desenhos Arquiteturais: Utiliza metodologias como C4, UML e BPMN para representar visualmente a estrutura e interações do sistema.
-   Análise de Impactos de Mudanças: Avaliação das consequências de alterações nos requisitos sobre a arquitetura do sistema.
-   Participação em Pré-venda: Pode contribuir no processo de pré-venda, proporcionando insights técnicos e avaliando a viabilidade da solução proposta.
-   Análise de Custos para o Negócio: Envolve a consideração de fatores econômicos na tomada de decisões arquiteturais.

### Arquitetura de Software:

-   Integração com Engenharia de Software: Faz parte da disciplina mais ampla da engenharia de software, influenciando diretamente o desenvolvimento do software.
-   Impacto na Estrutura Empresarial: Afeta a organização em diversos níveis, incluindo a formação de equipes, estruturação de componentes de software e comunicação interna.
-   Lei de Conway (Melvin Conway): Afirma que as organizações tendem a projetar sistemas que refletem suas próprias estruturas de comunicação interna.

### Papel do Arquiteto de Software:

O arquiteto de software desempenha um papel crucial no ciclo de vida do desenvolvimento de software, atuando como um elo vital entre os requisitos de negócio e a implementação técnica. Abaixo estão algumas das responsabilidades fundamentais desse profissional:

1.  **Transformação de Requisitos de Negócio em Padrões Arquiteturais:**
    
    -   Traduz os requisitos de negócio em uma arquitetura de software sólida, definindo padrões e diretrizes que guiarão o desenvolvimento.
2.  **Orquestração entre Desenvolvedores e Domínio:**
    
    -   Facilita a comunicação e entendimento mútuo entre a equipe de desenvolvimento e os stakeholders do domínio, assegurando que a solução atenda às necessidades do negócio.
3.  **Profundo Conhecimento de Conceitos e Modelos Arquiteturais:**
    
    -   Mantém um entendimento aprofundado dos conceitos arquiteturais relevantes, utilizando modelos e padrões estabelecidos para estruturar eficientemente os sistemas.
4.  **Reforço de Boas Práticas de Desenvolvimento:**
    
    -   Estabelece e reforça boas práticas de desenvolvimento, garantindo a consistência, escalabilidade e manutenibilidade do código-fonte.
5.  **Code Reviews:**
    
    -   Participa ativamente em revisões de código, identificando e corrigindo possíveis problemas arquiteturais, garantindo a conformidade com os padrões estabelecidos e promovendo a qualidade do código.

**Relação entre Arquitetura e Design:**

-   Ambos são componentes essenciais no desenvolvimento de software.
    
-   Arquitetura fornece a visão global e os princípios diretores.
    
-   Design concretiza esses princípios em implementações específicas de componentes.
    
-   A colaboração efetiva entre arquitetos e designers é crucial para criar sistemas coesos e eficientes.

**Sustentabilidade no Desenvolvimento de Software:**

-   **Custo do Desenvolvimento:**
    
    -   Desenvolver software é um processo dispendioso.
-   **Propósito do Software:**
    
    -   O software deve ter um propósito claro na resolução de um problema específico.
-   **Sustentabilidade Financeira:**
    
    -   O software deve ser concebido de forma a se pagar ao longo do tempo.
-   **Evolução do Negócio:**
    
    -   A arquitetura do software precisa acompanhar a evolução e as mudanças no negócio.
-   **Valor ao Longo do Tempo:**
    
    -   Quanto mais tempo o software permanece em operação, mais valor ele deve continuar gerando.
-   **Arquitetura Necessária:**
    
    -   Toda solução de software precisa ser arquitetada, considerando sua sustentabilidade a longo prazo.

**Pilares da Arquitetura de Software:**

-   **Estruturação:**
    
    -   _Fácil Evolução:_
        -   A estruturação da arquitetura deve facilitar a evolução do sistema ao longo do tempo, permitindo ajustes e expansões de forma eficiente.
-   **Componentização:**
    
    -   A arquitetura deve ser baseada em componentes, facilitando a modularidade e reutilização de partes específicas do sistema.
-   **Relacionamento entre Sistemas:**
    
    -   A interação e o relacionamento entre diferentes sistemas devem ser considerados na arquitetura, garantindo uma integração eficiente e uma comunicação adequada.
-   **Governança:**
    
    -   A governança refere-se ao conjunto de políticas, diretrizes e práticas que regulamentam a arquitetura. Deve assegurar a conformidade com padrões e garantir a consistência na tomada de decisões arquiteturais.

**Requisitos Arquiteturais (RAs):**

1.  **Performance:**
    
    -   Garantir que o sistema atenda aos requisitos de desempenho, como tempos de resposta rápidos e eficiência no consumo de recursos.
2.  **Armazenamento de Dados:**
    
    -   Definir como os dados serão armazenados, acessados e gerenciados, considerando requisitos de persistência e recuperação eficientes.
3.  **Escalabilidade:**
    
    -   Planejar a capacidade do sistema para lidar com o crescimento, garantindo que seja escalável conforme a demanda aumenta.
4.  **Segurança:**
    
    -   Incorporar medidas de segurança para proteger o sistema contra ameaças, incluindo controle de acesso, criptografia e práticas de segurança da informação.
5.  **Legal (Leis LGPD - Lei Geral de Proteção de Dados):**
    
    -   Garantir conformidade com leis e regulamentações, como a LGPD, para assegurar o tratamento adequado dos dados pessoais e a privacidade dos usuários.
6.  **Auditoria:**
    
    -   Implementar recursos que permitam rastrear e auditar atividades no sistema, facilitando a identificação de eventos importantes e a conformidade com normas e regulamentações.
7.  **Marketing:**
    
    -   Considerar requisitos relacionados ao marketing, como a integração com ferramentas de análise de dados, rastreamento de métricas de usuário e personalização da experiência do cliente.

**Características Arquiteturais:**

**Operacionais:**

1.  **Disponibilidade:**
    
    -   Garantir que o sistema esteja acessível e operacional conforme necessário, minimizando períodos de inatividade.
2.  **Recuperação de Desastres:**
    
    -   Planejar e implementar estratégias para recuperar o sistema após eventos catastróficos ou falhas.
3.  **Performance:**
    
    -   Assegurar que o sistema atenda aos requisitos de desempenho, incluindo tempos de resposta rápidos e eficiência.
4.  **Backup:**
    
    -   Implementar mecanismos para realizar cópias de segurança dos dados, garantindo a recuperação em caso de perda.
5.  **Confiabilidade e Segurança:**
    
    -   Incorporar medidas para garantir a confiabilidade das operações e a segurança dos dados e do sistema.
6.  **Robustez:**
    
    -   Desenvolver o sistema para resistir a situações adversas e lidar com falhas de forma resiliente.
7.  **Escalabilidade:**
    
    -   Projetar o sistema para crescer e se adaptar à demanda, garantindo escalabilidade horizontal ou vertical.

**Estruturais:**

1.  **Configurável:**
    
    -   Permitir a adaptação do sistema por meio de configurações, sem a necessidade de alterações no código-fonte.
2.  **Extensibilidade:**
    
    -   Facilitar a adição de novas funcionalidades ou módulos sem impactar negativamente o sistema existente.
3.  **Fácil Instalação:**
    
    -   Simplificar o processo de instalação do sistema, tornando-o acessível a usuários sem conhecimentos avançados.
4.  **Reuso de Componentes:**
    
    -   Projetar componentes de forma a permitir sua reutilização em diferentes partes do sistema ou em outros projetos.
5.  **Internacionalização:**
    
    -   Suportar múltiplos idiomas e culturas, adaptando-se a diferentes requisitos regionais.
6.  **Fácil Manutenção:**
    
    -   Estruturar o sistema de maneira que a manutenção seja eficiente e compreensível, facilitando correções e atualizações.
7.  **Portabilidade:**
    
    -   Garantir que o sistema possa ser executado em diferentes ambientes e plataformas sem grandes modificações.
8.  **Fácil Suporte (Logs, Debugging):**
    
    -   Facilitar o diagnóstico de problemas por meio de logs eficientes e ferramentas de debug, simplificando o suporte técnico.

**Cross-Cutting Concerns (Preocupações Transversais):**

1.  **Acessibilidade:**
    
    -   Considerar a acessibilidade para garantir que o sistema seja utilizado por pessoas com diferentes habilidades e necessidades, seguindo padrões e práticas inclusivas.
2.  **Processo de Retenção e Recuperação de Dados:**
    
    -   Definir políticas claras sobre quanto tempo os dados serão mantidos, assim como estratégias para a recuperação eficiente de informações quando necessário.
3.  **Autenticação e Autorização:**
    
    -   Implementar mecanismos robustos para autenticação, garantindo a identificação segura de usuários, e autorização, controlando o acesso a recursos do sistema.
4.  **Legal (LGPD - Lei Geral de Proteção de Dados):**
    
    -   Garantir que o sistema esteja em conformidade com as disposições legais, como a LGPD, para proteção adequada dos dados pessoais dos usuários.
5.  **Privacidade:**
    
    -   Incorporar práticas e funcionalidades que assegurem a privacidade dos usuários, protegendo informações sensíveis e seguindo princípios éticos.
6.  **Segurança:**
    
    -   Integrar medidas de segurança em todas as camadas do sistema para proteger contra ameaças, ataques e garantir a integridade dos dados.
7.  **Usabilidade:**
    
    -   Considerar a usabilidade como uma preocupação transversal, assegurando que o sistema seja intuitivo e fácil de usar, promovendo uma experiência positiva para o usuário.

**Perspectiva de Arquitetar Software de Qualidade (Performance, Escalabilidade, Resiliência):**

**Performance:**

-   **Definição:**
    
    -   Performance refere-se à eficiência com que um software executa suas operações.
-   **Unidades de Medida:**
    
    -   **Latência ou Response Time:**
        -   Tempo que o sistema leva para responder a uma solicitação.
    -   **Throughput:**
        -   Quantidade de operações que o sistema pode executar em um determinado período.
-   **Diferença entre Performance e Escalabilidade:**
    
    -   Performance está relacionada à eficiência em termos de tempo de resposta e quantidade de operações, enquanto escalabilidade refere-se à capacidade do sistema de lidar com um aumento na carga.
-   **Métricas para Medir a Performance:**
    
    -   **Diminuir Latência:**
        -   Medida em milissegundos, afetada por processamento, rede e chamadas externas.
    -   **Aumentar Throughput:**
        -   Quantidade de requisições processadas, diretamente ligado à latência.

**Considerações Adicionais:**

-   **Escalabilidade:**
    
    -   A capacidade do sistema de lidar com um aumento na carga, seja por aumento no número de usuários, transações ou dados.
-   **Resiliência:**
    
    -   A capacidade do sistema de se recuperar de falhas, mantendo a funcionalidade essencial mesmo em situações adversas.
-   **Estratégias para Melhorar Performance, Escalabilidade e Resiliência:**
    
    -   Otimização de algoritmos, uso eficiente de recursos, balanceamento de carga, replicação de servidores e implementação de práticas de recuperação de falhas.

**Principais Razões para Baixa Performance:**

1.  **Processamento Ineficiente:**
    
    -   Algoritmos ineficientes ou implementações de código que consomem mais recursos do que o necessário.
2.  **Recursos Limitados:**
    
    -   Disponibilidade inadequada de recursos, como CPU, memória e largura de banda.
3.  **Trabalho de Forma Bloqueante:**
    
    -   Operações que bloqueiam a execução do sistema, resultando em períodos de espera.
4.  **Acesso Serial a Recursos:**
    
    -   Requisições que dependem uma da outra, causando a execução sequencial em vez de paralela.

**Principais Formas de Aumentar Eficiência:**

1.  **Escala de Recursos:**
    
    -   Aumentar a capacidade dos recursos, seja horizontalmente (adicionando mais máquinas) ou verticalmente (melhorando a capacidade de cada máquina).
2.  **Melhoria de Algoritmos, Queries e Overhead de Frameworks:**
    
    -   Otimizar algoritmos, consultas a bancos de dados e minimizar o overhead introduzido por frameworks.
3.  **Concorrência e Paralelismo:**
    
    -   Utilizar técnicas de programação concorrente e paralela para realizar tarefas simultaneamente, aproveitando ao máximo os recursos disponíveis.
4.  **Bancos de Dados (Tipos de Bancos, Schema):**
    
    -   Escolher o tipo de banco de dados mais adequado para os requisitos do sistema, otimizar o schema para consultas eficientes e utilizar índices quando apropriado.
5.  **Caching:**
    
    -   Implementar estratégias de caching para armazenar temporariamente resultados de operações frequentes, reduzindo a necessidade de recálculos ou consultas extensas.

Essas abordagens podem ser combinadas e ajustadas conforme necessário para melhorar significativamente a performance de um sistema.

**Capacidade Computacional: Escala Vertical vs. Horizontal:**

-   **Escala Vertical:**
    
    -   Aumenta a capacidade computacional adicionando mais recursos (CPU, RAM, etc.) a uma única máquina.
    -   Útil para lidar com muitas requisições e aumentar a capacidade de processamento de uma máquina específica.
-   **Escala Horizontal:**
    
    -   Aumenta a capacidade computacional distribuindo a carga em várias máquinas, geralmente utilizando um balanceador de carga.
    -   Apropriada para lidar com um grande número de requisições distribuídas em vários servidores.

**Diferenças entre Concorrência e Paralelismo:**

-   **Concorrência:**
    
    -   Lidar com muitas tarefas ao mesmo tempo, mas não necessariamente simultaneamente.
    -   Pode envolver alternância rápida entre tarefas para dar a ilusão de execução simultânea.
-   **Paralelismo:**
    
    -   Fazer efetivamente muitas tarefas simultaneamente, aproveitando recursos multi-core ou máquinas distintas.

**Caching:**

-   **Cache na Bord: Edge Computing:**
    -   Colocação de caches próximos aos usuários finais, geralmente em servidores na "borda" da rede.
    -   Pode ser usado para armazenar dados estáticos, páginas web, funções internas (evitando processamento pesado) e objetos.

**Cache Exclusivo vs. Compartilhado:**

-   **Exclusivo:**
    
    -   Baixa latência, pois o cache está próximo do nó que o utiliza.
    -   Duplicação entre os nós, podendo gerar problemas relacionados a sessões.
-   **Compartilhado:**
    
    -   Maior latência, pois o cache pode estar localizado em um nó distante.
    -   Não há duplicação do cache, podendo ser eficiente para compartilhar informações entre diferentes partes do sistema, como sessões compartilhadas e banco de dados.

**Caching: Edge Computing:**

-   Cache realizado próximo ao usuário, evitando que as requisições cheguem ao Cloud.
-   Normalmente utilizado para armazenar arquivos estáticos, CDN (Content Delivery Network), serviços como Cloudflare Workers e Vercel.

**Escalabilidade vs. Performance:**

**Escalabilidade:**

-   **Descentralização:**
    -   **Disco Efêmero:**
        -   Utilização de armazenamento temporário, como discos efêmeros, para dados temporários e não essenciais.
    -   **Servidor de Aplicação vs. Servidor de Assets:**
        -   Separar servidores dedicados para lidar com a lógica da aplicação e a entrega de ativos (imagens, CSS, JS).
    -   **Cache Centralizado:**
        -   Utilizar um sistema de cache centralizado para compartilhar informações frequentemente acessadas.
    -   **Sessões Centralizadas:**
        -   Armazenar informações de sessão de forma centralizada para facilitar a escalabilidade horizontal.
    -   **Upload/Gravação de Arquivos:**
        -   Estratégias eficientes para lidar com o upload e gravação de arquivos, como o uso de serviços externos ou sistemas distribuídos.

**Escalando Banco de Dados:**

-   **Aumento de Recursos Computacionais:**
    -   Alocar mais recursos (CPU, RAM) para o banco de dados conforme necessário.
-   **Distribuindo Responsabilidades de Escrita vs. Leitura:**
    -   Utilizar técnicas como replicação para distribuir a carga entre servidores especializados em leitura e servidores especializados em escrita.
-   **Shards de Forma Horizontal:**
    -   Distribuir os dados horizontalmente em shards para permitir escalabilidade linear.
-   **Serverless:**
    -   Explorar opções serverless para escalar automaticamente em resposta à demanda.
-   **Otimização de Queries e Índices:**
    -   Utilizar índices de forma consciente para acelerar as consultas.
    -   Implementar ferramentas de monitoramento de desempenho de aplicativos (APM) para analisar o desempenho das queries.
    -   Utilizar "Explain" nas queries para entender e otimizar o plano de execução.
    -   Considerar a adoção de CQRS (Command Query Responsibility Segregation) para separar o processamento de comandos e consultas, otimizando cada fluxo de trabalho de maneira independente.
**Proxy Reverso:**

Um proxy reverso é um servidor intermediário que fica na frente de servidores web e gerencia as solicitações dos clientes, encaminhando essas solicitações para os servidores web correspondentes. Ele age como uma camada intermediária entre os clientes e os servidores, oferecendo benefícios como balanceamento de carga, segurança, e gerenciamento de tráfego.

**Soluções de Proxy Reverso:**

1.  **Nginx:**
    
    -   Um servidor web e proxy reverso popular conhecido por sua eficiência e baixo uso de recursos. Além de encaminhar solicitações, o Nginx oferece recursos avançados, como balanceamento de carga, compressão de conteúdo e manipulação de solicitações HTTP.
2.  **HAProxy:**
    
    -   Um software de proxy reverso e balanceador de carga altamente configurável. É reconhecido por sua capacidade de distribuir o tráfego de maneira eficiente entre os servidores, garantindo alta disponibilidade e desempenho.
3.  **Traefik:**
    
    -   Um proxy reverso e orquestrador de contêineres projetado para ambientes baseados em contêineres, como Docker. Traefik é conhecido por sua integração fácil com orquestradores de contêineres, como Kubernetes, e sua capacidade de detectar automaticamente novos serviços.

Essas soluções de proxy reverso desempenham um papel crucial na arquitetura de sistemas distribuídos, ajudando a otimizar o tráfego, melhorar a segurança e facilitar a manutenção e o gerenciamento de servidores web.

**Resiliência:**

-   **Definição:**
    
    -   Resiliência refere-se a um conjunto de estratégias adotadas para a adaptação de um sistema quando uma falha ocorre. É a capacidade do sistema de se recuperar e continuar a operar de maneira aceitável mesmo após enfrentar falhas ou perturbações.
-   **Importância das Estratégias de Resiliência:**
    
    -   Estratégias de resiliência são fundamentais para garantir que o sistema possa lidar com falhas de forma eficaz, mantendo a continuidade dos serviços.

**Estratégias de Resiliência:**

-   **Proteger e Ser Protegido:**
    -   Adotar mecanismos de autopreservação para proteger o sistema contra falhas.
    -   Evitar comportamentos egoístas em um sistema que está falhando, promovendo a cooperação entre componentes.
    -   Em certos contextos, ser lento pode ser pior do que ficar fora do ar. Portanto, estratégias de resiliência devem levar em consideração a importância do tempo na recuperação do sistema.

A resiliência é crucial em sistemas distribuídos e complexos, onde falhas podem ocorrer em diferentes partes do sistema. A implementação de estratégias eficazes de resiliência contribui para a robustez e confiabilidade do sistema como um todo.

**Health Check:**

-   Sem sinais de saúde, é impossível avaliar a condição do sistema.
-   Um sistema não saudável pode se recuperar se o tráfego for interrompido temporariamente.
-   Health check de qualidade envolve monitoramento contínuo e alertas precisos.

**Rate Limiting:**

-   Protege o sistema limitando o número de requisições por unidade de tempo.
-   Pode ser personalizado com preferências específicas por tipo de cliente.

**Circuit Breaker:**

-   Protege o sistema negando requisições e retornando erros (por exemplo, 500) quando necessário.
-   Circuito fechado: Requisições normais são permitidas.
-   Circuito aberto: Requisições não chegam ao sistema, resultando em erros instantâneos para o cliente.
-   Meio aberto: Permite uma quantidade limitada de requisições para verificar se o sistema pode responder.

**API Gateway:**

-   Garante que requisições inapropriadas não cheguem ao sistema, como requisições não autenticadas.
-   Pode implementar rate limiting e health check.

**Service Mesh (Malha de Serviço):**

-   Controla o tráfego de rede.
-   Evita a necessidade de implementar proteções diretamente no sistema, como rate limiting.
-   Comunicação segura usando mTLS (mutual Transport Layer Security).

**Trabalhar de Forma Assíncrona:**

-   Evita a perda de dados, permitindo que o servidor processe informações quando estiver disponível.
-   Útil ao trabalhar com message brokers.

**Garantias de Entrega: Retry:**

-   Exponential backoff e jitter podem ser usados para garantir uma tentativa de entrega eficiente, evitando sobrecargas em períodos de falha.

**Situações Complexas:**

-   Em casos complexos, como a queda de um message broker:
    -   Investigar se há perda de mensagens.
    -   Avaliar o comportamento do sistema quando fora do ar.
    -   Implementar estratégias para garantir resiliência, como mecanismos de failover.

Garantir a resiliência envolve uma abordagem holística, considerando vários aspectos do sistema e implementando estratégias apropriadas para diferentes cenários.